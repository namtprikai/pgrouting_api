    @timeit("Route Truck MM")
    def _route_truck_mm(
        self,
        o_lon: float,
        o_lat: float,
        d_lon: float,
        d_lat: float,
        toll_per_km: float = 30.0,
    ) -> Optional[Dict]:
        """Get truck route using DB tables + Python Dijkstra/A*, cached."""

        # 1. Cache key
        cache_key = (
            round(o_lon, 6),
            round(o_lat, 6),
            round(d_lon, 6),
            round(d_lat, 6),
            round(toll_per_km, 2),
        )
        if cache_key in self._route_cache:
            return self._route_cache[cache_key]

        # 2. Nearest nodes
        row = self._db_query_one(
            "SELECT nid FROM jpn_nodes ORDER BY geom <-> ST_SetSRID(ST_MakePoint(%s,%s),4326) LIMIT 1",
            (o_lon, o_lat),
        )
        if not row:
            return None
        src_node = row["nid"]

        row = self._db_query_one(
            "SELECT nid FROM jpn_nodes ORDER BY geom <-> ST_SetSRID(ST_MakePoint(%s,%s),4326) LIMIT 1",
            (d_lon, d_lat),
        )
        if not row:
            return None
        dst_node = row["nid"]

        # 3. Get ways within bounding box + small buffer
        min_lon, max_lon = min(o_lon, d_lon), max(o_lon, d_lon)
        min_lat, max_lat = min(o_lat, d_lat), max(o_lat, d_lat)

        ways = self._db_query_all(
            """
            SELECT gid, source, target, cost_s, reverse_cost, length_m, maxspeed_forward, highway,
                ST_AsText(geom) AS geom_wkt
            FROM jpn_ways
            WHERE NOT blocked
            AND geom && ST_Expand(ST_MakeEnvelope(%s,%s,%s,%s,4326), 0.05)
            """,
            (min_lon, min_lat, max_lon, max_lat),
        )
        if not ways:
            return None

        # 4. Build adjacency list
        adj: Dict[int, List[Tuple[int, float, int, str]]] = {}
        edge_geom: Dict[int, LineString] = {}
        edge_highway: Dict[int, str] = {}
        edge_length: Dict[int, float] = {}

        for w in ways:
            try:
                geom = wkt.loads(w["geom_wkt"])
            except:
                continue  # skip invalid WKT
            edge_geom[w["gid"]] = geom
            edge_highway[w["gid"]] = w["highway"]
            edge_length[w["gid"]] = w["length_m"]

            adj.setdefault(w["source"], []).append((w["target"], w["cost_s"], w["gid"], w["highway"]))
            if w["reverse_cost"] < 1e15:
                adj.setdefault(w["target"], []).append((w["source"], w["reverse_cost"], w["gid"], w["highway"]))

        # 5. Dijkstra
        heap = [(0, src_node, [])]  # (cost, node, path_edges)
        visited = {}
        path_edges: List[int] = []

        while heap:
            cost, node, path = heapq.heappop(heap)
            if node in visited:
                continue
            visited[node] = cost
            path_edges = path
            if node == dst_node:
                break
            for neigh, c, gid, hw in adj.get(node, []):
                if neigh not in visited:
                    heapq.heappush(heap, (cost + c, neigh, path + [gid]))

        if not path_edges:
            return None

        # 6. Aggregate geometry
        geom_lines = [edge_geom[gid] for gid in path_edges]
        full_line = LineString([pt for line in geom_lines for pt in line.coords])
        geom_geojson = mapping(full_line)

        # 7. Distance, travel_time, motorway_km
        distance_km = sum(edge_length[gid] for gid in path_edges) / 1000
        travel_time_h = 0
        motorway_km = 0
        gid_to_w = {w["gid"]: w for w in ways}

        for gid in path_edges:
            l = edge_length[gid]
            w = gid_to_w[gid]
            maxspeed = w["maxspeed_forward"]
            if not maxspeed:
                hw = edge_highway[gid]
                if hw.startswith("motorway"):
                    maxspeed = 120
                elif hw.startswith("trunk"):
                    maxspeed = 100
                elif hw.startswith("primary"):
                    maxspeed = 80
                elif hw.startswith("secondary"):
                    maxspeed = 60
                elif hw.startswith("tertiary"):
                    maxspeed = 40
                else:
                    maxspeed = 30
            travel_time_h += l / (maxspeed * 1000)
            if edge_highway[gid].startswith("motorway"):
                motorway_km += l / 1000

        toll_estimate_yen = round(motorway_km * toll_per_km)

        # 8. Entry / Exit IC
        entry_pt = Point(full_line.coords[0])
        exit_pt = Point(full_line.coords[-1])

        entry_ic = self._db_query_one(
            """
            SELECT name, lon, lat
            FROM motorway_ic
            ORDER BY ST_SetSRID(ST_MakePoint(lon,lat),4326) <-> %s
            LIMIT 1
            """,
            (entry_pt,),
        )
        exit_ic = self._db_query_one(
            """
            SELECT name, lon, lat
            FROM motorway_ic
            ORDER BY ST_SetSRID(ST_MakePoint(lon,lat),4326) <-> %s
            LIMIT 1
            """,
            (exit_pt,),
        )

        # 9. Build result
        route = {
            "geometry": geom_geojson,
            "distance_km": distance_km,
            "travel_time_h": travel_time_h,
            "motorway_km": motorway_km,
            "toll_estimate_yen": toll_estimate_yen,
            "entry_ic": entry_ic,
            "exit_ic": exit_ic,
        }

        self._route_cache[cache_key] = route
        return route
    